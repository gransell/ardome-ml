# Drop the item on the top of the return stack
# R: <item> redrop -- R:

: rdrop
	r> drop
;

# Decrement the number at the top of the return stack

: r1-
	r> 1- >r
;

: r1-@
	r1- r@
;

# Increment the number at the top of the return stack

: r1+
	r> 1+ >r
;

: r1+@
	r1+ r@
;

# Clear all stack items
# <item-1> ... clear --

: clear 
	begin 
		depth 0 > 
	while 
		drop 
	repeat 
;

# Display the top of stack as an aml filter graph
# <graph> render -- <graph>

: render
	filter:aml filename=- 
	decap
;

# Conditional check
# <value-1> <value-2> is -- <value-1> <value-1 == value-2>

: is
	1 pick = if
;

# Define basic image traits associated to the profile
# --

: profile
	0 is
		: fps fps_num=25 fps_den=1 ;
		: size width=720 height=576 ;
		: sar sar_num=59 sar_den=54 ;
	else
	1 is
		: fps fps_num=30000 fps_den=1001 ;
		: size width=720 height=480 ;
		: sar sar_num=10 sar_den=11 ;
	else
	2 is
		: fps fps_num=25 fps_den=1 ;
		: size width=720 height=576 ;
		: sar sar_num=118 sar_den=81 ;
	else
	3 is
		: fps fps_num=30000 fps_den=1001 ;
		: size width=720 height=480 ;
		: sar sar_num=40 sar_den=33 ;
	then
	drop
;

: pal_4:3 
	0 profile 
;

: ntsc_4:3 
	1 profile 
;

: pal_16:9 
	2 profile 
;

: ntsc_16:9 
	3 profile 
;

# Convenience method for visualisation
# <media> visualise -- <visualised-media>

: visualise 
	filter:visualise size sar
;

# Generate a background according to the selected profile
# -- <background>

: background
	colour: size fps sar
;

# Attach normalising filters to the input at the top of the stack
# <media> normalise -- <normalised-media>

: normalise
	filter:frame_rate fps
	filter:resampler
	filter:deinterlace
;

# Normalise all media on the stack
# <media-1> ... normalise! -- <normalised-media-1> ...

: normalise! 
	depth >r r@ 
	begin 
		r@ roll normalise 
		swap 1- 
		dup 0 = 
	until 
	rdrop drop 
;

# Join items for consecutive playout
# <media-1> ... <media-N> <N> group -- <media-1-to-N>

: group
	filter:playlist slots="%s"
;

# Join all items on the stack for consecutive playout
# <media-1> ... group! -- <media-1-to-...>

: group!
	depth group
;

: grid_calc

	1 1 
	begin
		2dup *
		3 pick < 
	while
		swap 2 *
		swap 2 *
	repeat

	begin
		2dup 1- * 
		3 pick >=
	while
		swap 1- swap
		dup 1- 2 pick *
		3 pick >=
		if 
			1-
		then
	repeat
;

# Generate a mosaic of some items on the stack
# <media-1> ... <media-N> <N> mosaic -- <mosaic-of-media>

: mosaic

	depth grid_calc

	swap 1.0 swap /
	swap 1.0 swap /
	0.0 0.0

	4 roll

	begin
		depth 1- roll
		5 pick 5 pick 5 pick 5 pick 
		filter:lerp @@x=%s @@y=%s @@w=%s @@h=%s 

		normalise filter:loop
		5 roll 5 roll 5 roll 2 pick + 5 roll 
		1 pick 0.9999 >=
		if
			nip 0.0 swap
			2 pick +
		then
		5 roll
		1- dup 0 =
	until

	drop drop drop drop drop
	
	background filter:compositor slots=1
	depth
	swap
	slots=%s
;

# Create a montage
# <input> <frames> montage -- <montage-showing-frames>

: montage
	>r
	r@ 2 +
	filter:extract frames=%s 
	r> 1 +
	filter:clip in=1 out=%s
	filter:montage orient=2 lines=0
;

# Cut media into two parts
# <media> <position> cut -- <media-to-position> <media-from-position>

: cut
	>r 
	dup
	r@ filter:clip out=%s
	swap
	r> filter:clip in=%s
;

# Render all items on the stack as an aml graph
# <media-1> ... render! -- <media-1> ...

: render!
	depth >r 
	begin
		r1-@ 0 >= 
	while
		r@ pick 
		render 
		drop
	repeat
	rdrop
;

# Default profile selection
pal_4:3

