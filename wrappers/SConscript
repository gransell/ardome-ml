import os

import owl.wrapper.c_sharp
import owl.wrapper.objc
from owl.reflection import header_file, header_files, assembly

from wrappers.objective_c import core_objc_bind_options
from wrappers.csharp import core_c_sharp_bind_options

Import(['local_env'])

local_env.packages( 'boost' , 'loki')
# Add core to the include path
local_env.Append( CPPPATH = ['#/external'])

dep_asses = []
dep_headers = [ os.path.join( local_env.root, 'wrappers', 'built_in_types.hpp' ),]
dep_hfs = []
for dh in dep_headers :
	dep_hfs.append(header_file(str(dh)))
dep_asses.append(assembly( 'dep_ass', header_files( dep_hfs, [], [] ), [] ))

defines = [('CORE_API', ''), ]
if local_env['PLATFORM'] == 'darwin' or local_env['PLATFORM'] == 'posix' :
	defines.extend([('OLIB_USE_UTF8', '1'), ('TCHAR', 'char'), ])
elif local_env['PLATFORM'] == 'win32' :
	defines.extend([('OLIB_USE_UTF16', '1'), ('TCHAR', 'wchar_t'), ])

local_env.Append( CPPPATH = [ '#/wrappers/objective_c/src' ] )

cl_src_dir = os.path.join( local_env.root, 'src', 'opencorelib', 'cl' )

#headers = [ header_file( os.path.join( cl_src_dir, 'typedefs.hpp') ),
			# header_file( os.path.join( cl_src_dir, 'core_enums.hpp') ),
			# header_file( os.path.join( cl_src_dir, 'basic_enums.hpp') ),
			# header_file( os.path.join( cl_src_dir, 'minimal_string_defines.hpp') ),
			# header_file( os.path.join( cl_src_dir, 'media_definitions.hpp') ),
#			header_file( os.path.join( cl_src_dir, 'time_code.hpp') ),
#			header_file( os.path.join( cl_src_dir, 'exception_context.hpp') ),
#			header_file( os.path.join( cl_src_dir, 'base_exception.hpp') ),
#			header_file( os.path.join( cl_src_dir, 'object.hpp') ),
			# header_file( os.path.join( cl_src_dir, 'media_time.hpp') ),
			# header_file( os.path.join( cl_src_dir, 'frames.hpp') ),
			# header_file( os.path.join( cl_src_dir, 'span.hpp') ),]
			# header_file( os.path.join( cl_src_dir, 'point.hpp') ),]
			
headers = [ #header_file( os.path.join( project_root , 'wrappers', 'bind_typedefs.hpp' ) ),
			header_file( os.path.join( cl_src_dir, 'core_enums.hpp') ),
			header_file( os.path.join( cl_src_dir, 'basic_enums.hpp') ),
			header_file( os.path.join( cl_src_dir, 'minimal_string_defines.hpp') ),
			header_file( os.path.join( cl_src_dir, 'media_definitions.hpp') ),
			header_file( os.path.join( cl_src_dir, 'time_code.hpp') ),
			# header_file( os.path.join( cl_src_dir, 'media_time.hpp') ),
			# #header_file( os.path.join( cl_src_dir, 'frames.hpp') ),
			header_file( os.path.join( cl_src_dir, 'span.hpp') ),
			header_file( os.path.join( cl_src_dir, 'point.hpp') ),
			header_file( os.path.join( cl_src_dir, 'assert.hpp') ),
			# #header_file( os.path.join( cl_src_dir, 'color.hpp') ),
			header_file( os.path.join( cl_src_dir, 'enforce.hpp') ),
			header_file( os.path.join( cl_src_dir, 'exception_context.hpp') ),
			header_file( os.path.join( cl_src_dir, 'invoker.hpp') ),
			header_file( os.path.join( cl_src_dir, 'ip_address.hpp') ),
			header_file( os.path.join( cl_src_dir, 'worker.hpp') ),
			header_file( os.path.join( cl_src_dir, 'jobbase.hpp') ),
			header_file( os.path.join( cl_src_dir, 'event_handler.hpp') ),
			header_file( os.path.join( cl_src_dir, 'base_exception.hpp') ),	
			# #header_file( os.path.join( cl_src_dir, 'logger.hpp') ) ,
			header_file( os.path.join( cl_src_dir, 'object.hpp') ) ,
			header_file( os.path.join( cl_src_dir, 'logtarget.hpp') ) ,
			header_file( os.path.join( cl_src_dir, 'point.hpp') ) ,
			header_file( os.path.join( cl_src_dir, 'rectangle.hpp') ),
			header_file( os.path.join( cl_src_dir, 'size.hpp') ),
			header_file( os.path.join( cl_src_dir, 'special_folders.hpp') ),
			header_file( os.path.join( cl_src_dir, 'uuid_16b.hpp') ) ,
			# #header_file( os.path.join( cl_src_dir, 'template.hpp') )
			]

obj = None;

owl_output_dir = os.path.join( local_env.root, 'wrappers', 'src' )

generate_files = True

if local_env['debug'] == '1' :
	print 'Debug build. Assuming AST and source files already generated by release build.'
	generate_files = False
	
		
if generate_files :
	print 'Building AST...'

	files = header_files( headers, defines, [] )

	core_assembly = assembly( 'Core', files, dep_asses )

	fd = open( 'assembly.xml', "w" )
	fd.write( core_assembly.xml_str() )
	

if local_env['PLATFORM'] == 'darwin' : 
	objc_wrapper = owl.wrapper.objc.objc()
	objc_options = core_objc_bind_options( os.path.join( local_env.root, 'bcomp' ), [core_assembly] )

	wrapper_files = objc_wrapper.bind( core_assembly, objc_options, 'objective_c/src' )
	obj = local_env.framework( 'AML', sources = wrapper_files['source_files'], headers = wrapper_files['header_files'], info_plist = 'objective_c/src/Info.plist' )
elif local_env['PLATFORM'] == 'win32' :    

	script_location = os.path.dirname( os.path.abspath( os.getcwd( ) ) )
	
	if generate_files :
		print 'Generating .NET source files...'
		csharp_wrapper = owl.wrapper.c_sharp.c_sharp()
		csharp_options = core_c_sharp_bind_options( os.path.join( local_env.root, 'external' ), owl_output_dir, [core_assembly] )

		wrapper_files = csharp_wrapper.bind( core_assembly, csharp_options )
	else :
		wrapper_files = {'source_files' : [], 'header_files' : [] }
		wrapper_files['header_files'] = local_env.Glob(os.path.join(owl_output_dir, '*.hpp'), True, False, True)
		wrapper_files['source_files'] = local_env.Glob(os.path.join(owl_output_dir, '*.cpp'), True, False, True)
		
		
	local_env.Append( CPPFLAGS = [ '/EHa', '/clr', '/AI "C:\\program\\Reference Assemblies\\Microsoft\\Framework\\v3.0"', '/FU "WindowsBase.dll"' ] ) 
	obj = local_env.shared_library( 'AML', sources = wrapper_files['source_files'], 
									headers = wrapper_files['header_files'], pre = [ os.path.join(owl_output_dir, 'precompiled_headers.cpp'), os.path.join(owl_output_dir, 'precompiled_headers.hpp') ] )
	 
Return( 'obj' )

