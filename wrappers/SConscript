import os
import pickle

import owl.wrapper.c_sharp
import owl.wrapper.objc
import owl.wrapper.binder
from owl.reflection.doxygen_ast import header_file, header_files, assembly

#from aml.wrapper.obj_c import core_objc_bind_options
from aml.wrapper.c_sharp.core_c_sharp_bind_options import core_c_sharp_bind_options

Import(['local_env'])

local_env.packages( 'boost_filesystem', 'boost_system', 'boost_date_time', 'boost_thread', 'boost_regex', 'loki' )

owl_output_dir = os.path.join( local_env.root, 'wrappers', 'generated_src' )

local_env.Append( CPPPATH = [ os.path.join(local_env.root, 'wrappers'), owl_output_dir, os.path.join( local_env.root, 'bcomp', 'owl', 'release', 'include' )] )


defines = [('CORE_API', ''), ]
if local_env['PLATFORM'] == 'darwin' or local_env['PLATFORM'] == 'posix' :
	defines.extend([('OLIB_USE_UTF8', '1'), ('TCHAR', 'char'), ])
elif local_env['PLATFORM'] == 'win32' :
	local_env.Append( CCFLAGS = '/Zm150' )
	defines.extend([('OLIB_USE_UTF16', '1'), ('TCHAR', 'wchar_t'), ('OLIB_ON_WINDOWS', '1') ])

generate_files = True

if local_env['debug'] == '1' :
	print 'Debug build. Assuming AST and source files already generated by release build.'
	generate_files = False
	
dep_ass_bo_map ={}

if generate_files :

	if local_env['PLATFORM'] == 'win32' :
		doxygen_path = os.path.join( local_env.root, 'bcomp', local_env['target'], 'doxygen.exe' )
	else :
		doxygen_path = os.path.join( local_env.root, 'bcomp', 'doxygen', 'bin', 'doxygen' )


	dependant_assembly_paths = [ 
								( 
									os.path.join( local_env.root, 'bcomp', 'owl', 'release', 'asts', 'OWL.assembly' ), 
									os.path.join( local_env.root, 'bcomp', 'owl', 'release', 'include' )
								) ]

	dep_asses = []
	for (dap, header_path) in dependant_assembly_paths :
		fd = open(dap, "r")
		(ass, bind_opts) = pickle.load( fd )
		ass.make_header_paths_absolute( header_path )
		dep_asses.append( ass )
		dep_ass_bo_map[ass.get_name()] = (ass, bind_opts)
		fd.close()

	cl_src_dir = os.path.join( local_env.root, 'src', 'opencorelib', 'cl' )
	
	headers = [ header_file( os.path.join( cl_src_dir, 'core_enums.hpp') ),
				header_file( os.path.join( cl_src_dir, 'basic_enums.hpp') ),
				header_file( os.path.join( cl_src_dir, 'minimal_string_defines.hpp') ),
				header_file( os.path.join( cl_src_dir, 'invoker.hpp') ),
				header_file( os.path.join( cl_src_dir, 'typedefs.hpp') ),
				header_file( os.path.join( cl_src_dir, 'object.hpp') ),
				header_file( os.path.join( cl_src_dir, 'media_definitions.hpp') ),
				header_file( os.path.join( cl_src_dir, 'time_code.hpp') ),
				header_file( os.path.join( cl_src_dir, 'media_time.hpp') ),
				header_file( os.path.join( cl_src_dir, 'frames.hpp') ),
				header_file( os.path.join( cl_src_dir, 'span.hpp') ),
				header_file( os.path.join( cl_src_dir, 'point.hpp') ),
				header_file( os.path.join( cl_src_dir, 'color.hpp') ),
				header_file( os.path.join( cl_src_dir, 'uuid_16b.hpp') ),
				header_file( os.path.join( cl_src_dir, 'event_handler.hpp') ),
				header_file( os.path.join( cl_src_dir, 'property_bag.hpp') ),
				header_file( os.path.join( cl_src_dir, 'serialization_helpers.hpp') ),
				header_file( os.path.join( cl_src_dir, 'size.hpp') ) ]
				
	if local_env['target'] == 'vs2008' :
		headers.append(header_file( os.path.join(cl_src_dir, 'base_exception.hpp' ) ) )
		headers.append(header_file( os.path.join(cl_src_dir, 'exception_context.hpp' ) ) )


	print 'Building AST...'
	files = header_files( headers, doxygen_path, defines, [] )
	aml_assembly = assembly( 'AML', files, dep_asses )
	
	# fd = open( 'assembly.xml', "w" )
	# fd.write( aml_assembly.xml_str() )
	# fd.close( )

	print 'Dumping assemblies to file'

	af = open( os.path.join( owl_output_dir, '../AML.assembly'), 'w' )
	bo_dict = { 'c_sharp' : ( 'aml.wrapper.c_sharp.core_c_sharp_bind_options', 'core_c_sharp_bind_options' ) }
	
	#Make the paths relative so that the pickled assembly can easily be reused on another machine
	aml_assembly.make_header_paths_relative( cl_src_dir )
	pickle.dump( (aml_assembly, bo_dict), af )
	af.close( )
	

local_env.copy_files( local_env[ 'stage_ast' ], os.path.join( local_env.root, 'bcomp', 'owl', 'release', 'asts', 'OWL.assembly') )
local_env.copy_files( local_env[ 'stage_ast' ], os.path.join( owl_output_dir, '../AML.assembly') )

if local_env['PLATFORM'] == 'darwin' : 
	# if generate_files:
	objc_wrapper = owl.wrapper.objc.objc()
	objc_options = core_objc_bind_options( os.path.join( local_env.root, 'bcomp', 'owl', 'release', 'py' ), 'output', [aml_assembly] )

	wrapper_files = objc_wrapper.bind( aml_assembly, objc_options, 'objective_c/src' )
	# else:
	# 	wrapper_files = {'source_files' : [], 'header_files' : [] }
	# 	wrapper_files['header_files'] = local_env.Glob(os.path.join(owl_output_dir, '*.hpp'), True, False, True)
	# 	wrapper_files['source_files'] = local_env.Glob(os.path.join(owl_output_dir, '*.mm'), True, False, True)
	
	obj = local_env.framework( 'AML', sources = wrapper_files['source_files'], headers = wrapper_files['header_files'], info_plist = 'objective_c/src/Info.plist' )
elif local_env['PLATFORM'] == 'win32' :    
	
	if generate_files :
		print 'Generating .NET source files...'
		csharp_wrapper = owl.wrapper.c_sharp.c_sharp()
		
		aml_options = core_c_sharp_bind_options( os.path.join( local_env.root, 'bcomp', 'owl', 'release', 'py' ), owl_output_dir, [aml_assembly] )

		options_binder = owl.utility.setup_options_binder( dep_ass_bo_map, 'c_sharp', aml_assembly, aml_options, os.path.join( local_env.root, 'bcomp', 'owl', 'release', 'py' ), owl_output_dir )
				
		wrapper_files = csharp_wrapper.bind( aml_assembly, options_binder )
		
		# Make paths relative
		wrapper_files[ 'source_files'] = [ s[ len(os.path.join(local_env.root, 'wrappers')) + 1 : ] for s in wrapper_files[ 'source_files' ] ]
		wrapper_files[ 'header_files'] = [ s[ len(os.path.join(local_env.root, 'wrappers')) + 1: ] for s in wrapper_files[ 'header_files' ] ]
		
		# Pickle the generated sources to file so that we can reuse them next time when not generating headers
		pickled_wf = open( os.path.join( owl_output_dir, '../', 'wrapper_files.pickle' ), 'w' )
		pickle.dump( wrapper_files, pickled_wf )
	else :
		pickled_wf = open( os.path.join( owl_output_dir, '../', 'wrapper_files.pickle' ), 'r' )
		wrapper_files = pickle.load( pickled_wf )
	
	pickled_wf.close( )

	wrapper_files[ 'source_files' ].extend( ['src/c_sharp/AMLConversionFunctions.cpp'] )
	wrapper_files[ 'source_files' ].extend( ['src/msw/aml_wrappers.rc'] )
	
	build_mode_str = 'release'
	if local_env['debug'] == '1' :
		build_mode_str = 'debug'
	
	obj = local_env.dot_net_library( 'AML', sources = wrapper_files['source_files'], 
									headers = wrapper_files['header_files'], 
									dot_net_assemblies = [ 
										os.path.join(os.environ['PROGRAMFILES'], 'Reference Assemblies', 'Microsoft', 'Framework', 'v3.0', 'WindowsBase.dll' ), 
										os.path.join( local_env.root, 'bcomp', 'owl', build_mode_str, 'bin', 'OWL.dll' ),  
									],
									pre = [ os.path.join('generated_src', 'precompiled_headers.cpp'), 'precompiled_headers.hpp' ] )
	
	local_env.copy_files( os.path.join( local_env[ 'stage_bin' ] ), os.path.join( local_env.root, 'bcomp', 'owl', build_mode_str, 'bin', 'OWL.dll' ) )
	local_env.copy_project_files( os.path.join( local_env[ 'stage_wrapper_py' ] ), os.path.join( 'py' ) )
	
	
local_env.release( obj )
	
Return( 'obj' )
